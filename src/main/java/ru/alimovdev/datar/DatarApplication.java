package ru.alimovdev.datar;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DatarApplication {

	public static void main(String[] args) {
		SpringApplication.run(DatarApplication.class, args);
	}

}
/*
26.10.2025 - 15:00/15:30#

Перепиши пожалуйста этот код на веб странице:

Код выше работал так: специалист Specialist мог просматривать запись Client к себе, администратор Administrator мог просматривать запись тех специалистов, Id которых находились в поле
private String specialistIdList; .Сами данные о записи к специалисту хранились у Client в поле private String appointmentDateTime; .Я хочу сделать так, чтобы данные о записи хранились
в отдельной таблице. Переписать код веб страницы надо согласно следующей логике: function searchTgUserById(tgUserId) там где находится // Логика для специалиста: специалист должен получить
данные о записи из таблицы: entity Appointment где данные из поле private String specialistId; должны совпадать с данными поля private String specialistId; у Specialist .Далее происходит
формирование столбцов .column с карточками .card с данными о записи Client. Формирование столбцов и карточек должно происходить по той же логике как и ранее, но отталкиваясь от новых
данных: теперь данные о дате и времени записи к Specialist должны находится в поле entity Appointment private String appointmentDateTime; и иметь то же представление, что и ранее в
private String appointmentDateTime; у Client, т.е. должны парсится соответствующим образом. Данные Id клиента Client, для которого создана запись, находятся в поле Appointment private long clientId; .Имя,
фамилия, отчество, дата рождения и телефон для карточки .card и модальных окон берутся из данных Client, а данне о времени и дате приема и заметка appointmentNote из Appointment, связанной с Client.
Далее // Логика для администратора: формирование столбцов и карточек для Specialist должны производится как и прежде, опираясь на данные о Specialist из поля Administrator private String specialistIdList;
,иерархия формирования должна оставаться прежней, только данные для формирования должны быть получены новым путем, который выше описал для // Логика для специалиста. Подытоживая: весь функционал кода на веб странице
должен быть сохранен, пользовательский интерфейс тоже - они прекрасно работают. Изменяется только логика получения данных. Попрошу еще вот что, допиши пожалуйста код для public class AppointmentController,
все необходимые методы:









//TODO Устаревший вариант
            //TODO 1. логика если tgSpecialist - entity Specialist - найден, запускается ФУНКЦИЯ ФОРМИРУЮЩАЯ СТОЛБЦЫ .column таким образом: надо найти в базе данных clients всех Client у которых поле specialistId совпадает с значением поля specialistId у tgSpecialist затем
            // у каждого найденного Client необходимо получить данные из поля appointmentDateTime в формате строки Strung "01.10.2025 - 12:20#15.10.2025 - 15:00#18.01.2026 - 09:10" .Строка appointmentDateTime формируется DateTimeFormatter.ofPattern("dd.MM.yyyy - HH:mm"),
            // и каждая дата разделяется символом "#". Необходимо разделить строку на массив из значений "01.10.2025 - 12:20", "15.10.2025 - 15:00" и т.д., затем распарсить из полученных строк дату - время. Создавать столбцы .column надо в соответствии с такой логикой:
            // столбцы .column представляют из себя график рабочего дня Specialist, список из entity Client - клиенты специалиста, у каждого клиента может быть несколько значений дата-время для записи к специалисту. Необходимо сравнить всех клиентов и их даты - время записи к специалисту
            //  и найти клиента с ближайшим значением даты - времени к текущему времени и дате, пусть это будет первый клиент. Саммый первый столбец .column должен иметь оглавление в виде ближайшей даты приема первого клиента, в столбец .column также добавляется карточка .card
            // которая должна отображать вверху поля клиента Client: surname name patronymic , ниже пусть будет размещены данные поля phoneNumber. У клиента Client существует поле visitDuration, данные
            // в строке из поля visitDuration имеют следующий вид: "60#100#30", эту строку необходимо разделить по символу "#", таким образом получится строковое представление числа, означающего продолжительность приема. В самом низу карточки надо разместить время начала приема
            // полученное из строки дата - время, а через дефис разместить время окончания приема: время начала приема + продолжительность приема, первое значение. Т.е. у клиента Client каждое значение дата - время имеет принадлежащее ему значение продолжительности приема.
            // Сама карточка .card  должна иметь высоту в зависимости от продолжительности приема клиента Client, пусть в таком соотношении каждые 10 (минут) продолжительности приема имеют эквивалент в 10px высоты карточки .card. Важно!- изменяться таким образом
            // должно только значение высоты .card. Далее карточки .card с данными клиентов Client должны размещаться в порядке, при котором время приема следующего клиента Client наступает позже времени приема предыдущего клиента Client. Таким образом столбец .column должен заполняеться
            // карточками .card в порядке сверху - вниз, при этом заполнение столбца .column карточками .card прекращается, если дата приема очередного клиента Client не совпадает с датой в оглавлении столбца .column, в таком случае создается новый столбец .column с оглавлением в виде даты следующей,
            // за датой первого столбца. Логика заполнения карточками .card второго .column и последующих столбцов .column аналогична логике заполнения карточками .card первого столбца, таким образом все клиенты Client имеющие прием у специалиста Specialist размещаются по столбцам .column и
            // карточкам .card в соответствии с отдаленностью предстоящего приема от текущей даты. Когда список клиентов Client исчерпан и каждый имеющийся "размещен" в своей карточке, помимо имеющихся столбцов .column с содержащимися карточками .card, вдобавок должен быть создан еще один, последний
            // столбец .column без содержимого, с текстом внутри "Кликнуть для записи клиента". При нажатии на каждый столбец .column должно появляться модальное окно .modal , в котором должно быть поле для ввода фамилии имени и отчества для поиска и добавления в поле данных surname name и patronymic клиента Client,
            // принадлежащего специалисту Specialist. После того как клиента Client найден, должна быть возможность назначить ему дату - время приема и продолжительность приема у специалиста Specialist, данные должны быть добавлены в поля Client в виде: в поле appointmentDateTime добавить в представлении "dd.MM.yyyy - HH:mm" + "#"
            // а в поле visitDuration в виде числа в строковом представлении, например "30" + "#"  .Также должна быть возможность добавить текстовую заметку в поле appointmentNote. Еще модальное окно .modal должно содержать дату рождения - поле birthdate и поле phoneNumber принадлежащие найденному Client.
            // После ввода даты - времени приема и продолжительность приема, данные клиента Client в базе данных clients должны обновиться. При нажатии на карточку .card должно появляться модальное окно .modal, в котором должны отображаться фамилия имя и отчество связанного с карточкой клиента Client,
            // данные о его дате - времени приема и продолжительности приема, данные поля phoneNumber поля birthdate и поля appointmentNote. Также должна быть кнопка с названием "Отменить запись", при нажатии которой должны обновляться следующие данные Client в базе данных clients: должна быть изъята строка или часть строки
            // соответствующая дате приема указанной в нажатой карточке .card, т.е. например для даты - времени 01.10.2025 - 12:20 удаляется строка с таким содержанием : "01.10.2025 - 12:20#". При этом строка с датами и временем приема должна разделяться по символу "#", необходимо проверить длинну полученного массива и если массив
            // длинной более чем на один элемент, и удаляется напрмер второй элемент, необходимо разделить по символу "#" строку из поля visitDuration и убрать из строки идентичный по порядку расположения в массиве элемент (в примере это второй элемент).

            //TODO 2. Шапка class="header" должна отсутствовать вовсе

            } else {
            const responseAdmin = await fetch(`${API_BASE}/administrators/${tgUserId}`); // Ищем администратора в бд
            const tgAdministrator = await responseAdmin.json(); // Найденный администратор, пользователь tg
            //Ищем id специалистов данного администратора
           const specialistsIdList = tgAdministrator.specialistIdList.split("/").filter(id => id.length > 1).map(id => parseInt(id.trim()));
            //Ищем специалистов данного администратора
            try {
                const specialists = await loadSpecialistsByIds(specialistsIdList);

                //TODO 3. логика если specialists найдены: в шапке class="header" с keys-container клавиши key-button должны быть в количестве равном числу элементов specialists, каждая клавиша должна содержать
                // фамилию имя и отчество из полей surname name patronymic специалиста Specialist. Далее генерируются столбцы .column в соответствии с заданием из TODO 1. для специалиста Specialist, данные которого находятся на самой первой клавише. При нажатии на клавишу с выбранным специалистом Specialist, должны
                // генерироваться столбцы .column в соответствии с заданием из TODO 1. для специалиста Specialist, клавиша с данными которого была нажата.

            } catch (error) {
                alert('Error loading SPECIALISTS: ' + error.message);
            }
            if (!responseAdmin.ok) {
                if (responseAdmin.status === 404) {

                     //TODO 4. логика для отображения страницы для user, id которого не был найден: должна отображаться пустая страница с текстом "Здравствуйте, гость!"

                    alert('Вы не зарегистрированы как администратор или специалист');
                } else {
                    throw new Error('Failed to load tgUser: ' + responseAdmin.status);
                    return;
                }
            }

            }
 */